\documentclass[submit]{harvardml}


\course{CS181-S24}
\assignment{Assignment \#1}
\duedate{11:59pm ET, February 10, 2024} 

\usepackage[OT1]{fontenc}
\usepackage[colorlinks,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage[pdftex]{graphicx}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{enumitem}
\usepackage{soul}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{todonotes}
\usepackage{listings}
\usepackage{common}
\usepackage{framed}
\usepackage{float}
\usepackage{ifthen}

\usepackage[mmddyyyy,hhmmss]{datetime}

% Solution environment
\newenvironment{solution}
  {\color{blue}\section*{Solution}}
{}

\definecolor{verbgray}{gray}{0.9}

\lstnewenvironment{csv}{
  \lstset{backgroundcolor=\color{verbgray},
  frame=single,
  framerule=0pt,
  basicstyle=\ttfamily,
  columns=fullflexible}}{}

 \DeclareMathOperator*{\limover}{\overline{lim}}


\begin{document}
\begin{center}
{\Large Homework 1: Regression}\\
\end{center}

\subsection*{Introduction}
This homework is on different three different forms of regression:
kernelized regression, nearest neighbors regression, and linear
regression.  We will discuss implementation and examine their
tradeoffs by implementing them on the same dataset, which consists of
temperature over the past 800,000 years taken from ice core samples.

The folder \verb|data| contains the data you will use for this
problem. There are two files:
\begin{itemize}
    \item \verb|earth_temperature_sampled_train.csv| 
    \item \verb|earth_temperature_sampled_test.csv|
\end{itemize} 

Each has two columns.  The first column is the age of the ice core
sample.  The second column is the approximate difference in a year's temperature (K) 
from the average temperature of the 1,000 years preceding it. The temperatures were retrieved from ice cores in
Antarctica (Jouzel et al. 2007)\footnote{Retrieved from
\url{https://www.ncei.noaa.gov/pub/data/paleo/icecore/antarctica/epica_domec/edc3deuttemp2007.txt}

Jouzel, J., Masson-Delmotte, V., Cattani, O., Dreyfus, G., Falourd, 
S., Hoffmann, G., … Wolff, E. W. (2007). Orbital and Millennial 
Antarctic Climate Variability over the Past 800,000 Years. 
\emph{Science, 317}(5839), 793–796. doi:10.1126/science.1141038}.
 
The following is a snippet of the data file:
 
\begin{csv}
# Age, Temperature
399946,0.51
409980,1.57
\end{csv}

\noindent And this is a visualization of the full dataset: 
\begin{center}
  \includegraphics[width=.8\textwidth]{images/sample_graph}
    \end{center}
  \noindent 


\textbf{Due to the large magnitude of the years, we will work in terms
  of thousands of years BCE in Problems 1-3.} This is taken care of
for you in the provided notebook.






\subsection*{Resources and Submission Instructions}
If you find that you are having trouble with the first couple
problems, we recommend going over the fundamentals of linear algebra
and matrix calculus (see links on website).  The relevant parts of the
\href{https://github.com/harvard-ml-courses/cs181-textbook/blob/master/Textbook.pdf}{cs181-textbook
  notes are Sections 2.1 - 2.7}.  We strongly recommend reading the
textbook before beginning the homework.

We also encourage you to first read the
\href{http://users.isr.ist.utl.pt/~wurmd/Livros/school/Bishop\%20-\%20Pattern\%20Recognition\%20And\%20Machine\%20Learning\%20-\%20Springer\%20\%202006.pdf}{Bishop
  textbook}, particularly: Section 2.3 (Properties of Gaussian
Distributions), Section 3.1 (Linear Basis Regression), and Section 3.3
(Bayesian Linear Regression). (Note that our notation is slightly
different but the underlying mathematics remains the same!).

\textbf{Please type your solutions after the corresponding problems
  using this \LaTeX\ template, and start each problem on a new page.}
You may find the following introductory resources on \LaTeX\ useful:
\href{http://www.mjdenny.com/workshops/LaTeX_Intro.pdf}{\LaTeX\ Basics}
and
\href{https://www.overleaf.com/learn/latex/Free_online_introduction_to_LaTeX_(part_1)}{\LaTeX\ tutorial
  with exercises in Overleaf}

Homeworks will be submitted through Gradescope. You will be added to
the course Gradescope once you join the course Canvas page. If you
haven't received an invitation, contact the course staff through Ed.

\textbf{Please submit the writeup PDF to the Gradescope assignment
  `HW1'.} Remember to assign pages for each question.

\textbf{Please submit your \LaTeX file and code files to the
  Gradescope assignment `HW1 - Supplemental'.} Your files should be
named in the same way as we provide them in the repository,
e.g. \texttt{hw1.pdf}, etc.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\begin{problem}[Setting up the Regression, 10pts]
As noted in the introduction, your goal is to predict temperature
variation given the year.  Before we start deriving and coding up our
regressions, we will interrogate the set-up of our problem.  

\begin{enumerate}
  \item These data were derived from ice core samples in Antarctica.
    Take a brief look at the
    \href{https://www.ncei.noaa.gov/pub/data/paleo/icecore/antarctica/epica_domec/edc3deuttemp2007.txt}{original
      data file}.  Briefly discuss how the data were processed: what kinds of
    decisions and corrections had to be made?  We know that different
    places on earth have different temperatures: what does the
    temperature in the temperature column correspond to?
        
  \item Even before doing any formal regressions, we see that there is
    some periodicity in the data: there are years that are warmer, and
    years that are cooler.  Suppose you are a government official
    advising on how much to worry about climate change.  Would it be
    reasonable to use this pattern as evidence that the earth will
    cool down again?  Why or why not, or to what extent?


  \item In the problems below, we will focus on interpolating
    temperatures for years not provided in the training set.  What
    kind of application would such a regression be useful for?

\end{enumerate}
  
\end{problem}

% qwer
\begin{solution}
\subsection*{1.} Since the data was derived from hard to reach Antarctic ice core samples, there was significant amount of prepossessing and processing that had to occur. There were likely corrections for incorrect data reported for negative years or extreme outlier temperatures, and time scales and measures were probably calibrates. The temperature in the column represents a global proxy, indicative of Earth's average temperature, not localized readings.

\subsection*{2.} The observed periodicity in temperature data should not be looked at in a silo when confronting climate change policy. Anthropogenic influences from human activity and fossil fuels that have impacted current warming trends should also be considered, amongst many other factors. 

\subsection*{3.} Interpolating temperatures for unrecorded years helps better quantify past climate trends and improve climate prediction scenarios. At core, this is what makes regression analyses so invaluable: it enables you to holistically comprehend data like long-term climate dynamics. 

\end{solution}
% rewq

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}[Optimizing a Kernel, 30pts]
Kernel-based regression techniques are similar to nearest-neighbor
regressors: rather than fit a parametric model, they predict values
for new data points by interpolating values from existing points in
the training set.  In this problem, we will consider a kernel-based
regressor of the form:
\begin{equation*}
  f_\tau(x^*) = \cfrac{\sum_{n} K_\tau(x_n,x^*) y_n}{\sum_n K_\tau(x_n, x^*)} 
\end{equation*}
where $\mathcal{D}_\texttt{train} = \{(x_n,y_n)\}_{n = 1} ^N$ are the
training data points, and $x^*$ is the point for which you want to
make the prediction.  The kernel $K_\tau(x,x')$ is a function that
defines the similarity between two inputs $x$ and $x'$. A popular
choice of kernel is a function that decays as the distance between the
two points increases, such as
\begin{equation*}
  K_\tau(x,x') = \exp\left\{-\frac{(x-x')^2}{\tau}\right\}
\end{equation*}
where $\tau$ represents the square of the lengthscale (a scalar value that 
dictates how quickly the kernel decays).  In this
problem, we will consider optimizing what that (squared) lengthscale
should be.

\noindent\emph{Make sure to include all required plots in your PDF.}

\begin{enumerate}
  
\item Let's first take a look at the behavior of the fitted model for different values of $\tau$. Implement the \texttt{kernel\_regressor} function in the notebook, and plot your model for years in the range $800,000$ BC to $400,000$ BC at $1000$ year intervals for the following three values of $\tau$: $1, 50, 2500$. Since we're working in terms of thousands of years, this means you should plot $(x, f_\tau(x))$ for $x = 400, 401, \dots, 800$. \textbf{The plotting has been set up} for you in the notebook already.

Include your plot in your solution PDF.

\textbf{In no more than 5 sentences}, describe how the fits change with $\tau$.

\item Now, we will evaluate the quality of each model \emph{quantitatively} by computing the error on some test set $\mathcal{D}_\texttt{test} = \{(x'_m, y'_m)\}_{m = 1} ^M$.  Write down the expression for MSE of $f_\tau$ over the test set as a function of the training set and test set. Your answer may include $\{(x'_m, y'_m)\}_{m = 1} ^M$, $\{(x_n, y_n)\}_{n = 1} ^N$, and $K_\tau$, but not $f_\tau$.

\item Suppose we used the training set as our test set, that is, we evaluated the expression above with $\mathcal{D}_\texttt{test} = \mathcal{D}_\texttt{train}$, and chose the value of $\tau$ which gave the smallest loss.  What value of $\tau$ would be picked?  Why is setting $\mathcal{D}_\texttt{test} = \mathcal{D}_\texttt{train}$ a bad idea?
   
\emph{Hint: consider what value of $\tau$ would be optimal, for $\tau$ ranging in $(0, \infty)$. We can consider $f_\tau(x^*)$ as a weighted average of the training responses, where the weights are proportional to the distance to $x^*$, and the distance is computed via the kernel. What happens to $K_\tau(x, x')$ as $\tau$ becomes very small, when $x = x'$? What about when $x \neq x'$?}

\item Let us compute the MSE on the provided test set (that is, not the training set). Write Python code to compute the MSE with respect to the same lengthscales as in Part 1. Which model yields the lowest test set MSE? 

\item Describe the time and space complexity of kernelized regression with respect to the size of the training set $N$.  How, if at all, does the size of the model---everything that needs to be stored to make predictions---change with the size of the training set $N$?  How, if at all, do the number of computations required to make a prediction for some input $x^*$ change with the size of the training set $N$?

\end{enumerate}

\end{problem}


% qwer
\begin{solution}
 \includegraphics[width=0.5\linewidth]{hw1/ss1.png}.
\newline 1. The $\tau$ value affects the proximity of the data to the model. As in, a more fitted estimated regression is correlated to a lower $\tau$ value. We'd thus expect to get overfit with a lower $\tau$ value and underfit a high $\tau$ value. 
\newline 2. Given the training data \(D_{\text{train}} = \{(x_n, y_n)\}_{n=1}^N\) and the test data \(D_{\text{test}} = \{(x'_m, y'_m)\}_{m=1}^M\), and defining the kernel function as \(K_\tau(x, x') = \exp\left\{-\frac{(x - x')^2}{\tau}\right\}\), the Mean Squared Error (MSE) of the kernel regressor \(f_\tau\) over the test set is expressed as:

\[
\text{MSE}(f_\tau) = \frac{1}{M} \sum_{m=1}^M \left( f_\tau(x'_m) - y'_m \right)^2
\]

where the prediction \(f_\tau(x'_m)\) for a test point \(x'_m\) is given by the weighted average of training responses:

\[
f_\tau(x'_m) = \frac{\sum_{n=1}^N K_\tau(x_n, x'_m) y_n}{\sum_{n=1}^N K_\tau(x_n, x'_m)}
\]

Here, \(K_\tau(x_n, x'_m)\) quantifies the influence of a training point \(x_n\) on the prediction at \(x'_m\), which diminishes as the distance between \(x_n\) and \(x'_m\) increases, modulated by the parameter \(\tau\).
\newline 3. Selecting \(\tau\) by minimizing loss on \(D_{\text{test}} = D_{\text{train}}\) biases towards very small \(\tau\) values, enhancing overfitting. This practice yields a model excessively tailored to the training instances, impairing its generalizability. It's thus critical to evaluate a model's performance using separate training and testing data to get the most realistic assessment of its predictive capabilities.
\newline 5. The space and time complexities of kernelized regression with respect to the training set size $N$ are as follows:

\textbf{Space Complexity:} The model's space complexity is \textit{linear} ($O(N)$). The amount of memory required increases linearly with the number of data points $N$.

\textbf{Time Complexity for Prediction:} Making a prediction involves computing the kernel function between the new input $x^*$ and each of the $N$ training points, resulting in a \textit{linear} time complexity ($O(N)$) for each prediction.

\textbf{Model Size:} The size of the kernelized regression model directly correlates with the training set size, as all training data points are retained. Consequently, the model size grows linearly with $N$.

\textbf{Computations for Prediction:} The number of computations required for making a single prediction scales linearly with the training set size, involving $N$ kernel evaluations and the subsequent operations to generate the prediction.


\end{solution}
% rewq

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\begin{problem}[Kernels and kNN, 20pts]

Now, let us compare the kernel-based approach to an approach based on
nearest-neighbors.  Recall that kNN uses a predictor of the form
  \begin{equation*}
    f(x^*) = \frac{1}{k} \sum_n y_n \mathbb{I}(x_n \texttt{ is one of k-closest to } x^*)
  \end{equation*}

\noindent where $\mathbb{I}$ is an indicator variable. For this problem, you will use the \textbf{same dataset as in Problem 1}.


%\textbf{For this problem, you may also use the second half of the notebook at {\color{red} update name} \texttt{T1\_P1-2.ipynb}.} 

\textbf{Note that our set of test cases is not comprehensive: just because you pass does not mean your solution is correct! We strongly encourage you to write your own test cases and read more about ours in the comments of the Python script.}

\vspace{0.5cm}
\noindent\emph{Make sure to include all required plots in your PDF.}


\begin{enumerate}

\item The kNN implementation \textbf{has been provided for you} in the notebook. Run the cells to plot the results for $k=\{1, 3, N-1\}$, where $N$ is the size of the dataset.

  Describe what you see: what is the behavior of the functions in
  these three plots?  How does it compare to the behavior of the
  functions in the three plots from Problem 1? In particular, are
  there situations in which kNN and kernel-based regression
  interpolate similarly?

\item Compute the MSE on the test set for each value of $k$.  Which solution has the lowest MSE?  

\item As in Problem 1, describe the space and time complexity of kNN.  How does what is stored to compute predictions change with the size of the training set $N$?  How does the computation needed to compute the prediction for a new input depend on the size of the training set $N$? (For the latter, justify based off of your implementation.)

\end{enumerate}

\end{problem}


% qwer
\begin{solution}
 \includegraphics[width=0.5\linewidth]{hw1/ss2.png}.
1. Altering K evidently has a sizable impact on the size and shape of the graph. For smaller integer values like k=1 and k=3, the flow shape of the graph holds. When this is altered to k = n - 1, the regression appears more linear along y = - 5.5. K's role is simlar to Tao in that as you raise the value, the regression slowly becomes more linear. This makes the regressions more broad. 
\\ \newline 2. As follows: 

\textbf{Space Complexity:} \textit{Linear} ($O(N)$), attributable to the necessity of retaining the entire training dataset, thus incrementally increasing memory requirements with $N$.

\textbf{Time Complexity for Prediction:} Each prediction's time complexity is also \textit{linear} ($O(N)$), due to the required computation of kernel functions across $N$ training instances for each input $x^*$.

\textbf{Model Size:} Scales with $N$, as the model encapsulates all training instances for future predictions, underscoring a linear growth pattern.

\textbf{Computational Load for Prediction:} Directly proportional to $N$, since there are $N$ kernel computations per prediction. 

Therefore, kernelized regression. 

\newline 3. The k-Nearest Neighbors (kNN) algorithm has both a linear space and time complexity (\(O(N)\)), where \(N\) is the size of the data. Specifically:

\begin{itemize}
    \item \textbf{Space Complexity:} Storing the entire training dataset mandates a \textit{linear} storage increase with \(N\).
    \item \textbf{Time Complexity for Prediction:} We are primarily doing distance calculations to ascertain the \(k\) nearest neighbors from \(N\) training points. This is also a \textit{linear} trajectory.
\end{itemize}

This dependency underscores kNN's enhanced resource requisites for larger datasets, directly correlating the model's complexity and computational expenditure with \(N\), thereby impacting scalability and efficiency.
\end{solution}
% rewq


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 4
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\begin{problem}[Modeling Climate Change 800,000 Years Ago, 30pts]

Our last regression will be linear regression.  We currently only have
a one dimensional input, the year.  To create a more expressive linear
model, we will introduce basis functions.
\vspace{1em}
\noindent\emph{Make sure to include all required plots in your PDF.}

\begin{enumerate}
\item 
We will first implement the four basis regressions below. (The first basis has been implemented for you in the notebook as an example.) Note that we introduce an addition transform $f$ (already into the provided notebook) to address concerns about numerical instabilities.
\begin{enumerate}
  \item $\phi_j(x)= f(x)^j$ for $j=1,\ldots, 9$. $f(x) = \frac{x}{1.81 \cdot 10^{2}}.$
  \item $\phi_j(x) = \exp\left\{-\cfrac{(f(x)-\mu_j)^2}{5}\right\}$ for $\mu_j=\frac{j + 7}{8}$ with $j=1,\ldots, 9$. $f(x) = \frac{x}{4.00 \cdot 10^{2}}.$
  \item $\phi_j(x) =  \cos(f(x) / j)$ for $j=1, \ldots, 9$. $f(x) = \frac{x}{1.81}$.
  \item $\phi_j(x) = \cos(f(x) / j)$ for $j=1, \ldots, 49$. $f(x) = \frac{x}{1.81 \cdot 10^{-1}}$. \footnote{For the trigonometric bases (c) and (d), the periodic nature of
cosine requires us to transform the data such that the 
lengthscale is within the periods of each element of our basis.}
\end{enumerate}

{\footnotesize * Note: Please make sure to add a bias term for
all your basis functions above in your implementation of the 
\verb|make_basis|.}

Let 
$$ \mathbf{\phi}(\mathbf{X}) = 
\begin{bmatrix} 
\mathbf{\phi}(x_1) \\
\mathbf{\phi}(x_2) \\
\vdots \\
\mathbf{\phi}(x_N) \\
\end{bmatrix} \in \mathbb{R}^{N\times D}.$$
You will complete the \verb|make_basis| function which must return
$\phi(\mathbf{X})$ for each part 
(a) - (d). You do NOT need to submit this
code in your \LaTeX writeup.

For each basis create a plot of your code graphing the least squares
regression line trained on your training data against a scatter plot
of the training data. Boilerplate plotting code is provided in the
notebook.
\textbf{All you need to include 
in your writeup for this part are these four plots.}
\vspace{1em}
\end{enumerate}
\end{problem}


\newpage
\begin{framed}
\noindent\textbf{Problem 4} (cont.)\\
\begin{enumerate}
\setcounter{enumi}{1}
\item 
Now we have trained each of our basis regressions.  For each basis
regression, compute the MSE on the test set.  Discuss: do any of the
bases seem to overfit?  Underfit?  Why?

% \item Make a claim regarding whether this basis overfits, 
% underfits, or fits well. Write 1-2 sentences explaining your 
% claim using the train and test negative log-likelihood and MSE.

% \end{itemize}

\item Briefly describe what purpose the transforms $\phi$ serve: why are they helpful?

\item As in Problems 1 and 2, describe the space and time complexity of linear regression.  How does what is stored to compute predictions change with the size of the training set $N$?  How does the computation needed to compute the prediction for a new input depend on the size of the training set $N$?  How do these complexities compare to those of the kNN and kernelized regressor?

\item Briefly compare and constrast the different regressors: kNN,
  kernelized regression, and linear regression (with bases).  Are some
  regressions clearly worse than others?  Is there one best
  regression?  How would you use the fact that you have these multiple
  regression functions?
  
\end{enumerate}
Note:
Recall that we are using a 
different set of inputs $\mathbf{X}$ for each basis (a)-(d). 
Although it may seem as though this prevents us from being able 
to directly compare the MSE since we are using different data, 
each transformation can be considered as being a part of our model. 
Contrast this with transformations (such as standardization) that cause the variance of the target $\mathbf{y}$ to be different; in these cases the
MSE can no longer be directly compared.

\end{framed}

% qwer
\begin{solution}
1.  \includegraphics[width=0.5\linewidth]{hw1/ss3.png}.
\newline 2. Errors: Part (a);

 Train MSE: 6.28; Test MSE: 8.89


Part (b);

 Train MSE: 6.83; Test MSE: 8.94


Part (c);

 Train MSE: 4.11; Test MSE: 10.63


Part (d);

 Train MSE: 0.60; Test MSE: 73.03
 Over fitting is when the model performs well on the training data but bad on unseen data. This happens when the model is too complex and there's significantly lower MSE for the training set compared to the test set. 
 Under fitting is when a model is too simple to capture the underlying pattern. If the MSE is high for both sets, this might be under fitting. 
 \newline 3. The transformer maps the original input features into a higher dimensional space where the relationship between the input and target variable may become more linear. The original relationship may be non-linear or too complex, so we can transform a non=linear regression problem into a linear problem. This improves accuracy for both training and test sets. 
 \newline 4. \textbf{Space Complexity, Linear Regression:} The model's space requirement is $O(D)$, where $D$ is the number of features, including any basis expansions. This contrasts with ($O(N)$)for kNN and kernelized regression, which store the entire training set.  \newline \textbf{Time Complexity for Prediction,
Linear Regression:}  Predicting with linear regression has a complexity of $O(D)$ dependent on feature count rather than training set size $N$. \newline \textbf{Model Size vs. Training Set Size $N$ Linear Regression:} Model size is fixed by the feature count $D$, not $N$, which makes it helpful as N increases and datasets scale to be larger. This makes prediction time constant regardless of $N$. \newline \textbf{Computational Comparison:} \newline kNN and Kernelized Regression: Both methods involve storing the complete training dataset, leading to increased space complexity with $N$ and linearly scaling prediction time. \newline Linear Regression: Demonstrates space efficiency and faster prediction times, particularly beneficial for datasets with a large number of instances $N$. Its primary computational demand is during the training phase, especially prominent in high-dimensional data scenarios.
\newline 5. All three of the regression techniques excel in unique situations. kNN is particularly useful in capturing complex patterns but is more computationally expensive for large data sets. Linear regression ultimately is the most central compromise between complexity and efficiency, which makes it suitable for a wide-range of applications. 


\newline 


\end{solution}
% rewq

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 5
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{problem}[Deriving Linear Regression, 10pts]

  In the previous problems, you focused on implementing regressions
  and exploring their fits on data. Now we will turn to some more
  analytic work.  Specifically, the solution for the least squares
  linear regressions ``looks'' kind of like a ratio of covariance and
  variance terms.  In this problem, we will make that connection more
  explicit. \\

  \noindent Let us assume that our data are tuples of scalars $(x,y)$ that are
  described by some joint distribution $p(x,y)$.  For clarification, the joint distribution $p(x,y)$ is just another way of saying the ``joint PDF'' $f(x,y)$, which may be more familiar to those who have taken Stat 110, or equivalent. \\
  
  \noindent We will consider the process of fitting these data from this distribution with the best linear model
  possible, that is a linear model of the form $\hat{y} = wx$ that
  minimizes the expected squared loss $E_{x,y}[ ( y - \hat{y} )^2
  ]$.\\

\noindent \emph{Notes:} The notation $E_{x, y}$ indicates an
expectation taken over the joint distribution $p(x,y)$.  Since $x$ and
$y$ are scalars, $w$ is also a scalar.
  
  \begin{enumerate}

  \item Derive an expression for the optimal $w$, that is, the $w$
    that minimizes the expected squared loss above.  You should leave
    your answer in terms of moments of the distribution, e.g. terms
    like $E_x[x]$, $E_x[x^2]$, $E_y[y]$, $E_y[y^2]$, $E_{x,y}[xy]$
    etc.

\item Provide unbiased and consistent formulas to estimate $E_{x, y}[yx]$
 and $E_x[x^2]$ given observed data $\{(x_n,y_n)\}_{n=1}^N$.

\item In general, moment terms like $E_{x, y}[yx]$, $E_{x, y}[x^2]$,
  $E_{x, y}[yx^3]$, $E_{x, y}[\frac{x}{y}]$, etc. can easily be
  estimated from the data (like you did above).  If you substitute in
  these empirical moments, how does your expression for the optimal
  $w^*$ in this problem compare with the optimal $w^*$ that we see in
  Section 2.6 of the cs181-textbook?

\item Many common probabilistic linear regression models assume that
  variables x and y are jointly Gaussian.  Did any of your above
  derivations rely on the assumption that x and y are jointly
  Gaussian?  Why or why not?
    
\end{enumerate}
  
\end{problem}

\begin{solution}
1. To derive the optimal \(w\) for minimizing the expected squared loss \(E_{x,y}[(y - wx)^2]\), we start with:

\[L(w) = E_{x,y}[(y - wx)^2]\]

Expanding and minimizing \(L(w)\) leads to:

\[\frac{dL(w)}{dw} = -2E_{x,y}[xy] + 2wE_{x,y}[x^2] = 0\]

Solving for \(w\) yields:

\[w = \frac{E_{x,y}[xy]}{E_{x,y}[x^2]}\]

This expression indicates that the optimal \(w\) is a ratio of the covariance of \(x\) and \(y\) to the variance of \(x\).

2. i. The unbiased and consistent estimator for \(E_{x,y}[yx]\) is given by:
\[
\hat{E}_{x,y}[yx] = \frac{1}{N-1} \sum_{n=1}^N (x_n - \bar{x})(y_n - \bar{y})
\]
where \(\bar{x}\) and \(\bar{y}\) are the sample means of \(x\) and \(y\), respectively.
\newline ii. The estimator for \(E_{x}[x^2]\) can be directly calculated as:
\[
\hat{E}_{x}[x^2] = \frac{1}{N} \sum_{n=1}^N x_n^2
\]
3. The substitution of empirical moments makes the expression for the optimal \(w^*\) closely resembles the formula derived in Section 2.6 of the textbook, emphasizing the core principle that linear regression parameters are deeply tied to the covariance and variance of the data. \newline 4. The derivation minimizes the expected squared loss, which doesn't presuppose the joint distribution to be Gasussian. This is universally applicable. 



\end{solution}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Name and Calibration
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection*{Name}

\subsection*{Collaborators and Resources}
Whom did you work with, and did you use any resources beyond cs181-textbook and your notes?


\end{document}
